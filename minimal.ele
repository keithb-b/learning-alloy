abstract sig Location{}

abstract sig Zone{
    locations: disj some Location
}

abstract sig Vehicle{
  //structural relations
    ,locations: some Location

    ,zones: some Zone
    ,locationsInZone: zones one -> some locations

  //state
    ,var disj locked, unlocked: set zones
}{
  //facts about derived relations
    all z: zones | z.locations = locationsInZone[z]
  //facts about state
    zones = locked + unlocked
}

one sig DriverFront extends Location{}
one sig PassengerFront extends Location{}
one sig PassengerSide extends Location{}
one sig Rear extends Location{}

one sig People extends Zone{}
abstract sig Cargo extends Zone{}
one sig RearCargo extends Cargo{}
one sig OtherCargo extends Cargo{}

sig Transit extends Vehicle {
}{
   zones = 
         People 
       + RearCargo 
       + OtherCargo

   locations = 
         Rear
       + PassengerSide
       + DriverFront
       + PassengerFront

   locationsInZone = 
         People     -> DriverFront
       + People     -> PassengerFront
       + RearCargo  -> Rear
       + OtherCargo -> PassengerSide
}

//observations
pred Vehicle::zoneLocked[z: Zone]{
    z in this.locked
}

pred Vehicle::zoneUnchanged[z: Zone]{
    z & this.locked   = z & this.locked'
    z & this.unlocked = z & this.unlocked'
}

pred Vehicle::zonesOtherThanUnchanged[z: Zone]{
    all z: this.zones - z | this.zoneUnchanged[z]
}

pred Vehicle::otherVehiclesUnchanged{
   all v: Vehicle - this | v.unchanged
}

pred Vehicle::unchanged{
   this.locked'   = this.locked
   this.unlocked' = this.unlocked
}

//actions
pred Vehicle::unlock[z: Zone]{
    this.unlocked' = this.unlocked + z
    this.locked'   = this.locked   - z
    this.zonesOtherThanUnchanged[z]
    this.otherVehiclesUnchanged
    
}

pred Vehicle::lock[z: Zone]{
    this.locked'   = this.locked   + z
    this.unlocked' = this.unlocked - z
    this.zonesOtherThanUnchanged[z]
    this.otherVehiclesUnchanged
}

pred skip{
    all v: Vehicle |
        v.unchanged
}

//invariant frame conditions
assert aZoneIsLockedOrUnlocked{
   all v: Vehicle |
      no v.locked & v.unlocked
}

//event reification
abstract sig Command {}
one sig Unlock, Lock, Skip extends Command{}

fun on: Command -> Vehicle -> Zone {
      Unlock -> {v: Vehicle, z: Zone| v.unlock[z]}
    + Lock   -> {v: Vehicle, z: Zone| v.lock[z]}
}

fun skip: Command {
    {c : Skip | skip}
}

fun commands: set Command {
    on.Zone.Vehicle + skip
}
    
//demonstration    
fact trace{
    //initally
    all v:Vehicle |
        all z: v.zones | v.zoneLocked[z]
    always
        (   skip
         or one v: Vehicle |
                 one z: Zone |
                       v.unlock[z]
                    or v.lock[z]
        )

}

pred allUnlocked{
    eventually
        all v:Vehicle | 
            all z: v.zones | not v.zoneLocked[z]
}

run {allUnlocked} for exactly 2 Transit, 8 Command, 8 Time

