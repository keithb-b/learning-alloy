abstract sig Location{}

abstract sig Zone{
    locations: disj some Location
}

abstract sig Vehicle{
  //structural relations
    ,locations: some Location

    ,zones: some Zone
    ,locationsInZone: zones one -> some locations

  //state
    ,var disj locked, unlocked: set zones
}{
  //facts about derived relations
    all z: zones | z.locations = locationsInZone[z]
  //facts about state
    zones = locked + unlocked
}

one sig DriverFront extends Location{}
one sig PassengerFront extends Location{}
one sig PassengerSide extends Location{}
one sig Rear extends Location{}

one sig People extends Zone{}
abstract sig Cargo extends Zone{}
one sig RearCargo extends Cargo{}
one sig OtherCargo extends Cargo{}

sig Transit extends Vehicle {
}{
   zones = 
         People 
       + RearCargo 
       + OtherCargo

   locations = 
         Rear
       + PassengerSide
       + DriverFront
       + PassengerFront

   locationsInZone = 
         People     -> DriverFront
       + People     -> PassengerFront
       + RearCargo  -> Rear
       + OtherCargo -> PassengerSide
}

//observations
pred Vehicle::zoneLocked[z: Zone]{
    z in this.locked
}

pred Vehicle::zoneUnchanged[z: Zone]{
    z & this.locked   = z & this.locked'
    z & this.unlocked = z & this.unlocked'
}

pred Vehicle::zonesOtherThanUnchanged[z: Zone]{
    all z: this.zones - z | this.zoneUnchanged[z]
}

//actions
pred Vehicle::unlock[z: Zone]{
    this.unlocked' = this.unlocked + z
    this.locked'   = this.locked   - z
    this.zonesOtherThanUnchanged[z]
}

pred Vehicle::lock[z: Zone]{
    this.locked'   = this.locked   + z
    this.unlocked' = this.unlocked - z
    this.zonesOtherThanUnchanged[z]
}

pred skip{
    all v: Vehicle |
        all z: v.zones |
            v.zoneUnchanged[z]
}

//
assert aZoneIsLockedOrUnlocked{
   all v: Vehicle |
      no v.locked & v.unlocked
}

enum Command {Unlock, Lock, Skip}
fun _unlock: Command -> Vehicle -> Zone {
    Unlock -> {v: Vehicle, z: Zone| v.unlockAZone[z]}
}

fun _lock: Command -> Vehicle -> Zone {
    Lock -> {v: Vehicle, z: Zone| v.lockAZone[z]}
}

fun _skip: Command {
    {c : Skip | skip}
}

fun commands: set Command {
    (_unlock + _lock).Zone.Vehicle + _skip
}
    
//demonstration    
pred trace{
    //initally -- it would be nice to have a (yes, redundant!) keyword for this
    all v:Vehicle |
        all z: v.zones | v.zoneLocked[z]
    always
           (skip
        or one v: Vehicle |
               one z: Zone |
                      v.unlockAZone[z]
                   or v.lockAZone[z])
    eventually
        all v:Vehicle | 
            all z: v.zones | not v.zoneLocked[z]
}

run {trace} for exactly 1 Transit, 6 Time
