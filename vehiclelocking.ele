module VehicleLocking

open Vehicle //includes Door
open Location
open Lock
open Transit

fact doorsAreOnTheirVehicle{
    all d: Door |
        all v: Vehicle |
            d in v.doors <=> v = d.on 
}

fact doorsAreLocatedOnOneVehicleOnly{
    all d: Door |
        all v, u: Vehicle | 
            d in v.doors and d in u.doors <=> v = u
}

fact doorsAreInOneLocationOnly{
    all v: Vehicle |
        all l, m: v.locations | 
                v.doorAt[l] = v.doorAt[m] <=> l = m
}

fact locationsOnVehicles{
    all l: Location |
        some v: Vehicle |
            l in v.locations
}

fact doorsAreLockedToBeginWith{
    all d: Door |
        d.lockState = Locked
}

//Checks
//The below should be true of the above:

pred doorsOnAVehicle {
    all d: Door |
        one v: Vehicle |
            d in v.doors
}

pred doorsOnTheirVehicle{
    all d: Door |
            d in d.on.doors
}

pred doorsInALocation{
    all d: Door |
        one v: Vehicle |
            one l: v.locations |
                d = v.doorAt[l]
}

pred doorsInOneLocationOnly{
    all v: Vehicle |
        all d: v.doors |
            #(v.doorAt :> d) = 1
}

pred doorsAtLocationsOnTheirVehicle{
    all d: Door |
        all l: Location |
            d = d.on.doorAt[l] => l in d.on.locations
}

pred validStructure{
    doorsOnAVehicle
    doorsOnTheirVehicle
    doorsInALocation
    doorsInOneLocationOnly
    doorsAtLocationsOnTheirVehicle
}

pred doorsWereLocked{
	all d: Door |
       d.lockState = Locked
}


pred initalDoorStates{
    doorsWereLocked
}

pred doorStateMachine{
    all d: Door | {
        historically locked[d]
        unlockCommanded[d]
        eventually unlocked[d]
    }     
}

check{
    validStructure
    initalDoorStates
    doorStateMachine
} for 1 Transit, 4 Door, 4 Location, 2 Time expect 0

//As  we should see demonstrated thus:

pred aTransit{
    0 < #Transit
}

run aTransit for 1 Transit, 4 Door, 4 Location, 2 Time
