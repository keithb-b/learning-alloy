module VehicleLocking

open Vehicle //includes Door
open Location
open Lock
open Transit

fact doorsAreOnOneVehicleOnly{
    //Jackson style
    doors in Vehicle one -> Door
}

fact noUnneededLocations{
    all l: Location |
        some v: Vehicle |
            l in v.locations
}

fact initalState{
	doorsAreLocked
}

//Checks
//The below should be true of the above:

pred aVehicleHasLocationsForDoors{
    all v: Vehicle |  v.locations != none
}


pred aDoorBelongsToAVehicle{
    all d: Door |
        one v: Vehicle |
            d in v.doors
}

pred aDoorIsInALocationOnAVehicle{
    all d: Door |
        one v: Vehicle |
            one l: v.locations |
                d = v.doorAt[l]
}

pred aDoorIsOnOneVehicleOnly{
    all disj u, v: Vehicle |
        no v.doors & u.doors
} 

pred aDoorIsInOneLocationOnly{
    all v: Vehicle |
        all d: v.doors |
            #(v.doorAt :> d) = 1
}

pred doorsAreLocked{
    all d: Door | d.lockState = Locked
}

//it's a shame that we can't organize assertions this way, too. [or can we!?]
pred validStructure{
    aVehicleHasLocationsForDoors
    aDoorBelongsToAVehicle
    aDoorIsOnOneVehicleOnly
    aDoorIsInOneLocationOnly
}

pred consistentBehaviour{
    doorsAreLocked
}

pred vehicleModel{
    validStructure
    consistentBehaviour
}

check theModelAsChecked{vehicleModel} for exactly 2 Transit, 8 Door, 4 Location, 2 Time expect 0 //counterexamples

//As  we should see demonstrated thus:

run theModelAsRun{vehicleModel} for exactly 2 Transit, 8 Door, 4 Location, 2 Time
